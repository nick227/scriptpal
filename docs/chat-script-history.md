# Chat Script History Guide

## Problem at hand
Switching scripts in the UI without switching the underlying `scriptId` that travels with the chat request lets the assistant continue working against the previous script's context and history. Because the service always scopes history to the `scriptId` attached to each `/chat` call, stale IDs make the AI mix together the wrong pages, personas, and prompts as soon as the next message is sent.

## How the script ID flows today
- The client-provided ID is parsed out of `req.body.scriptId` (or `context.scriptId`) before any routing logic runs, so `chatController.startChat` attaches it to the conversation context and logs it with every request (server/controllers/chatController.js:235, server/controllers/chatController.js:246). A new `Chat` instance is built with that ID before LangChain routing happens (server/controllers/chatController.js:327).
- Inside `Chat.processMessage`, metadata and the intent classifier see the same `scriptId` to decide whether the incoming prompt is script-specific or general chit-chat (server/controllers/chat/Chat.js:63, server/controllers/chat/Chat.js:66). `buildContext` keeps `scriptId` in the outbound context and fetches the last few rows of script history when the intent is script conversation (server/controllers/chat/Chat.js:139, server/controllers/chat/Chat.js:171). General conversations explicitly reset history (`context.chatHistory = []` and `context.disableHistory = true`) so the assistant does not reuse stale interactions (server/controllers/chat/Chat.js:167).
- `ChatHistoryManager` refuses to persist or retrieve rows without a script scope, so every saved interaction winds up tied to the `scriptId` the chat instance was created with (server/controllers/chat/ChatHistoryManager.js:9, server/controllers/chat/ChatHistoryManager.js:21, server/controllers/chat/ChatHistoryManager.js:51). The repository layer also filters and writes by that ID, which means the database never mixes conversations across scripts (server/repositories/chatMessageRepository.js:4, server/repositories/chatMessageRepository.js:18). The Prisma schema mirrors that guarantee-`chat_messages` has an optional `scriptId`, and every record is linked back to the owning `Script` (server/prisma/schema.prisma:124, server/prisma/schema.prisma:127, server/prisma/schema.prisma:134, server/prisma/schema.prisma:135).

## Routes that reinforce script scoping
- `POST /chat` reads the `scriptId` that the chat client sends (server/routes.js:46) and starts the routing that ultimately produces the LangChain response. When the client wants to pull history for display it must call `GET /chat/messages?scriptId=` (server/routes.js:52), and that handler insists on a valid script ID before talking to the repository (server/controllers/chatController.js:82, server/controllers/chatController.js:90).
- Saving message-by-message UI state happens through `POST /chat/messages`, so the front-end should keep that `scriptId` around when it mirrors history locally (server/routes.js:58). If the UI needs to clear a conversation before handing the assistant a fresh canvas, it can hit `DELETE /chat/messages/:scriptId`, which erases all stored rows for that script and that user (server/routes.js:64, server/controllers/chatController.js:196, server/controllers/chatController.js:198).

## Why the AI gets confused when scripts flip
Because the same `Chat` object and `ChatHistoryManager` continue to request and save entries under whichever `scriptId` is still in the request, flipping a script without updating that ID exposes the next prompt to the previous script's history (server/controllers/chat/Chat.js:171). The `intentClassifier` still sees the old title and content, so it routes back into whatever flow was active, and the assistant keeps referencing irrelevant XML tags or beats from the prior script.

## Recommendation
1. Treat a script switch as a clean boundary: always emit the new `scriptId` in every `/chat` payload and every `/chat/messages` call so LangChain pulls history for the correct script (server/controllers/chatController.js:235, server/controllers/chatController.js:327, server/controllers/chatController.js:82). If you want to start over with that script, call `DELETE /chat/messages/:scriptId` before the first prompt to drop stored rows (server/routes.js:64, server/controllers/chatController.js:196).
2. When `scriptId` is unavailable, keep the request on the general-conversation branch so history stays disabled (`context.chatHistory = []` and `context.disableHistory = true`) and the assistant ignores unrelated interactions (server/controllers/chat/Chat.js:167).
3. Keep UI state tied to the same `scriptId` you sent to `/chat`: refresh from `GET /chat/messages` when the ID changes, and only reuse stored responses if that ID stays constant (server/controllers/chatController.js:82, server/controllers/chatController.js:196, server/prisma/schema.prisma:124).
4. If you need an explicit "new conversation" signal without deleting rows, allow the client to set `context.disableHistory` inside the `/chat` body so the next prompt ignores older interactions even though they still exist in the database (server/controllers/chat/Chat.js:167).
