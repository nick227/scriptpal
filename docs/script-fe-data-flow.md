# Script Front-End Data Flow

This note traces how user scripts flow from UI input to the editor, along with the backend round-trip for creating or renaming scripts. It also highlights an existing gap that keeps `USER_SCRIPTS_PANEL` empty for freshly signed-in users and prevents the untitled script from ever appearing.

## 1. Bootstrapping the script UI

- `init-clean.js` wires everything together: it creates `App`, `ScriptPalAPI`, `ScriptPalUser`, a shared `StateManager`, `EventManager`, `ScriptStore`, and `PersistenceManager`, then waits for persistence to be ready (`public/js/init-clean.js:10-79`).
- Once authentication is confirmed, `initScriptsUI` instantiates `ScriptsUIBootstrap` with the shared managers (`public/js/init-clean.js:59-81`). The bootstrap locates `UI_ELEMENTS.USER_SCRIPTS_PANEL`, `script-selector`, and the editor toolbar, then instantiates `ScriptsController`, `ScriptWidget`, and `ScriptListWidget`, wiring them to `StateManager` via `StateManager.KEYS.USER` (`public/js/widgets/script/ScriptsUIBootstrap.js:18-114`).
- `ScriptWidget` builds the panel DOM (header, "New Script" button, `<ul>` list), registers state listeners on `StateManager.KEYS.SCRIPTS`/`CURRENT_SCRIPT`, and primes the renderer with whatever state is currently available (`public/js/widgets/script/ScriptWidget.js:24-139`).
- `ScriptStore` serves as the single source of truth and event bridge (`public/js/stores/ScriptStore.js:11-430`). `ScriptsController` hooks event and state listeners, surfaces commands (`SELECT`, `CREATE`, `LIST`, `DELETE`), and funnels script updates into `EditorWidget` (`public/js/controllers/ScriptsController.js:18-189`).
- The editor subscribes via `ScriptsController.setEditorWidget`, so `handleCurrentScriptChange` drives `EditorWidget` to update its `content` component and history whenever a new script becomes current (`public/js/controllers/ScriptsController.js:74-183` and `public/js/widgets/editor/EditorWidget.js:520-720`).
- `PersistenceManager` listens for `StateManager.KEYS.CURRENT_SCRIPT` changes to mirror script metadata (`currentScriptId`, `title`, `content`, etc.) into `localStorage`, so that a script selection persists across reloads (`public/js/managers/PersistenceManager.js:44-190`).

## 2. Script list to editor synchronization

- `ScriptWidget` (panel) and `ScriptListWidget` (dropdown) both subscribe to `StateManager.KEYS.SCRIPTS` and `CURRENT_SCRIPT`. When the script array or current script changes, each renderer (see `RendererFactory.createScriptRenderer`) rerenders the list and highlights the active script (`public/js/widgets/script/ScriptWidget.js:88-128`, `public/js/widgets/script/ScriptListWidget.js:70-210`, `public/js/renderers.js:146-210`).
- Selecting a script in either widget publishes `EventManager.EVENTS.SCRIPT.SELECT_REQUESTED`. `ScriptsController.handleSelectRequested` resolves the ID and calls `ScriptStore.selectScript`/`loadScript`, which either returns the cached version or fetches it from `ScriptPalAPI.getScript` (`public/js/stores/ScriptStore.js:119-204`, `public/js/classes/api.js:424-472`).
- When `ScriptStore.setCurrentScript` runs it updates `StateManager.KEYS.CURRENT_SCRIPT_ID` and `CURRENT_SCRIPT`, publishes `SCRIPT:SELECTED`, and lets `ScriptsController` and the widgets respond. `EditorWidget` is therefore kept in sync with the latest script body and version (`public/js/stores/ScriptStore.js:293-380`).

## 3. New script creation round-trip

1. User clicks "New Script" either in the panel (`ScriptWidget.handleCreateScript`) or the dropdown (`ScriptListWidget.handleCreateScript`), which publish `EventManager.EVENTS.SCRIPT.CREATE_REQUESTED` (`public/js/widgets/script/ScriptWidget.js:50-133`, `public/js/widgets/script/ScriptListWidget.js:132-180`).
2. `ScriptsController.handleCreateRequested` pulls the current user from `StateManager.KEYS.USER`, sanitizes the title/content payload, and calls `ScriptStore.createScript` (`public/js/controllers/ScriptsController.js:141-169`).
3. `ScriptStore.createScript` POSTs to `/script` via `ScriptPalAPI.createScript` (`public/js/stores/ScriptStore.js:276-327`, `public/js/classes/api.js:432-470`). The server controller (`server/controllers/scriptController.js:17-45`) validates the request, then `scriptModel.createScript` (with `prisma`) inserts a new `script`, a `scriptVersion`, and a `scriptCommand` (`server/models/script.js:27-86`).
4. The API response returns the standardized script (`id`, `title`, `versionNumber`, `content`). `ScriptStore` unshifts it into `this.scripts`, updates `StateManager.KEYS.SCRIPTS`, and calls `setCurrentScript`, which in turn sets `CURRENT_SCRIPT_ID`, `CURRENT_SCRIPT`, and publishes `SCRIPT:CREATED`/`SCRIPT:SELECTED` (`public/js/stores/ScriptStore.js:288-322`).
5. The widgets re-render the new row, and `ScriptsController.handleCurrentScriptChange` pushes the empty content into `EditorWidget`, clearing history and history state, readying the user for editing (`public/js/controllers/ScriptsController.js:172-218`).
6. `PersistenceManager` saves the new script metadata to `localStorage`, so a refresh already knows which script is current (`public/js/managers/PersistenceManager.js:44-140`).

## 4. Rename (title page) round-trip

1. The title page UI enters edit mode, and on each keystroke `TitlePageManager.handleTitleInputChange` updates `titlePageData` and invokes `ScriptStore.updateScriptTitle` for an optimistic UI update (`public/js/widgets/editor/title/TitlePageManager.js:225-474`).
2. `ScriptStore.updateScriptTitle` adjusts the local cache and state array so both widgets show the new name immediately (`public/js/stores/ScriptStore.js:342-357`), and `PersistenceManager` notices the `CURRENT_SCRIPT` change.
3. `TitlePageManager.scheduleTitlePersist` throttles the request (400 ms). When it fires it calls `ScriptStore.updateScript`, passing the title, author, current content, and version number (`public/js/widgets/editor/title/TitlePageManager.js:468-508`, `public/js/stores/ScriptStore.js:201-256`).
4. `ScriptStore.updateScript` formats the content, validates it, and executes `ScriptPalAPI.updateScript` (`public/js/classes/api.js:472-516`). The server validates XML-like content only when the string is non-empty but now allows empty content for metadata-only changes, so `scriptModel.updateScript` can still create a new `ScriptVersion`, update the base script, and insert a command for auditing (`server/controllers/scriptController.js:46-105`, `server/models/script.js:60-104`).
5. The API response contains the latest version metadata; `ScriptStore` refreshes its cache, updates `StateManager.KEYS.SCRIPTS`, calls `setCurrentScript`, and emits `SCRIPT.UPDATED` so UI and persistence stay consistent (`public/js/stores/ScriptStore.js:201-330`).

## 5. Pain point: `USER_SCRIPTS_PANEL` stays empty

- `ScriptsController` is the only module that loads scripts from the API (`handleUserChange` -> `scriptStore.loadScripts` -> `ScriptStore.createScript` if the list is empty). That method is only invoked in response to future `StateManager.KEYS.USER` changes (`public/js/controllers/ScriptsController.js:61-118`).
- On page load (or after login/registration), the user state is already populated before `ScriptsController` exists, so its `handleUserChange` never runs. The UI bootstrap does the right thing (`this.stateManager.subscribe(...); this.handleUserChange(this.stateManager.getState(...));`), but `ScriptsController` omits that initial call and thus never hits `loadScripts` or creates the untitled script (`public/js/widgets/script/ScriptsUIBootstrap.js:89-110`).
- Result: `ScriptStore.scripts` stays empty, the renderer has nothing to show, and the default untitled script is never created for new users even though every other path (create button, persistence, editor) is wired correctly.
- **Fix idea**: mirror `ScriptsUIBootstrap` by invoking `this.handleUserChange(this.stateManager.getState(StateManager.KEYS.USER));` right after subscribing in `ScriptsController` so a pre-existing user triggers the first load/creation (`public/js/controllers/ScriptsController.js:61-118`).

## 6. Persistence pipeline fragility

- Every successful `ScriptStore.setCurrentScript` propagates through `StateManager.KEYS.CURRENT_SCRIPT` so `PersistenceManager.handleScriptChange` logs the script metadata (`id`, `title`, `author`, `content`, etc.) to `localStorage` under the keys `currentScriptId`/`currentScriptState`/`currentScriptTitle` (`public/js/managers/PersistenceManager.js:44-120`). Those values are rehydrated on reload (`loadPersistedState`) and then merged with the next authoritative API response when `ScriptsController` finishes loading scripts for the user (`public/js/managers/PersistenceManager.js:163-231`).
- Editor edits trigger `EditorSaveService.save`, which normalizes/validates the content, then calls `ScriptStore.updateScript`, which formats the payload via `ScriptFormatter` and issues `ScriptPalAPI.updateScript`. The server creates a new version and replies with the latest script, so `ScriptStore` refreshes the cache, dispatches `SCRIPT.UPDATED`, and persistence writes the new content (`public/js/widgets/editor/save/EditorSaveService.js:120-240`, `public/js/stores/ScriptStore.js:201-330`).
- Title/author edits go through the same pipeline, but metadata-only updates send the current script content verbatim (often an empty string). `ScriptFormatter.format` rejects empty strings (`public/js/services/scriptFormatter.js:10-110`), so `ScriptStore.updateScript` throws before the API call runs. The UI still shows the new title locally, yet nothing reaches the server or persistence layer, so a refresh resets to the previous name/author. To persist metadata we need to skip formatting (or accept empty content) and allow `updateScript` to call the API even when `content` is blank.
- The “lines not persisting” workstream rides on the same validation gate: `EditorSaveService.validateContent` wraps plain text in `<script>`/valid tags and only proceeds if the DOM parser detects at least one valid content node (`public/js/widgets/editor/save/EditorSaveService.js:20-120`). Any validation failure (missing tags, unexpected markup, empty content) aborts before the API call, so the script never makes it to the database despite user edits. Capturing the validation error / helper message and surfacing it in the toolbar would make it easier to know when persistence silently drops edits.
- **Fix ideas**:
  1. Allow `ScriptStore.updateScript` to bypass `ScriptFormatter` when the incoming content is empty while still calling the API with the rest of the metadata (title/author) so persistence can keep pace with TitlePage edits.
  2. Surface validation failures from `EditorSaveService.validateContent` so editors know why lines do not persist, and consider relaxing the whitelist (or auto-wrapping) so plain screenplay lines are always accepted.
